# CheerpJ POC

This project is an attempt to provide a browser-native implementation of vZome without abandoning all the legacy Java code, and without requiring a running server as in the client/server approach used until now.  There are two possible approaches for a pure web client: Java-to-Javascript source transpiling, and Java-to-WebAssembly compilation.  This project uses the latter approach, relying on [CheerpJ](https://www.leaningtech.com/pages/cheerpj.html).

I had previously tried TeaVM, and even an earlier student project.  There were simply too many hurdles for those attempts, the performance was not acceptable, and I believe there were still important gaps in functionality.  CheerpJ seems to address all those shortcomings; the technology finally seems mature enough to use.  The tooling is excellent, the documentation is fair to good, and the overall experience has been pretty rewarding in a short amount of time.

## Status

The app is pretty functional as a reader for vZome models.  It has some built-in models, a progress indicator with status message, and it can read almost any vZome file from the local disk.  (Models that use Zomic are the exception, only because I have not added the ANTLR JARs to the set that I am compiling.)  Finally, I am supporting a few exporters at the moment.

The first real error I encountered in the Java code was the use of `Thread
.getContextClassLoader()` in a number of places.  I know I've gone back
and forth on this over the years, but my Googling today seems to clearly
indicate that I should *always* use `getClass().getClassLoader()`.  I've
made those changes; it may cause trouble with Oculus or perhaps the server
for client/server, but if so, I'll deal with it by passing a `ClassLoader`
where necessary.

There are also some Jackson mechanisms that still give the CheerpJ JRE some trouble, causing failures at runtime.  This is the reason I cannot support "mesh" and "cmesh" exports at the moment.

## Building the Test App

The `cheerpj.bash` script offers a complete, start-from-scratch solution to compiling all the necessary JARs, placing everything under `public` ready to use.  The script is overkill for ongoing development, since it recompiles all JARs from scratch, even the third-party dependencies.

In a separate shell (still from the `client` directory) do `npm install`.  This is a one-time action, at least until we introduce more dependencies in `package.json`.  Next, do `npm run start` to build the client code and start the development server, which also launches the client page in your browser.  The dev server will force a page reload whenever the static files under `public` have changed.

If you have to change the Java code, you can run `./cheerpj.bash fast` in your first shell to skip recompiling all the libraries, and just recompile the two vZome JARs.

For what it is worth, I keep Eclipse open with the Java code, and VS Code open on the client project.

## Web Technology

The app was created using `create-react-app`, which hides a lot of the build complexity; see the other `README-cra.md`, which was generated by CRA.

Obviously, I am using React as the main rendering framework.  I did some Googling a few years ago, and concluded that React should be easier to learn than Angular, and I believe it is now ahead in "market" share and still gaining.

For state management, I'm using Redux and `react-redux`, as well as `redux-thunk`.  I borrowed some ideas from Henrik Joreteg's excellent book, "Human Redux", though I'm not using his `redux-bundler` library.  I find his philosophy pretty compelling, and I'm keeping my components focused on rendering, with all the state management in "bundles".  This is his term, though I'm using the idea more manually; see `createStore` and `combineReducers` in `index.js`.

For the UI elements, I have embraced `react-bootstrap`.  It is a little limiting, and I need to find a good Bootstrap theme to go with it, but it definitely lowers the learning curve; I haven't done any CSS wrangling since I started using it.

Finally, and importantly, I'm using `react-three-fiber` to handle the 3D rendering.  It is a nice React wrapper for `three.js`.  The documentation is a bit terse, but there are enough examples to work out most things without needing to go whining on the forums.
